# Архитектура Nexbot

Полная документация архитектуры системы Nexbot, компонентов и потока данных.

## Обзор

Nexbot использует модульную многослойную архитектуру с message bus в основе. Система спроектирована как:
- **Декомпозированная**: Компоненты общаются через message bus
- **Расширяемая**: Легко добавлять новые каналы, инструменты и навыки
- **Async-friendly**: Фоновые задачи, cron задания и subagents
- **Высокопроизводительная**: Эффективные goroutines и очереди

## Диаграмма архитектуры

```
┌─────────────────────────────────────────────────────────────┐
│                        MESSAGE BUS                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Inbound Queue│  │ Outbound Queue│  │ Task Queue   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
 ┌───────▼───────┐   ┌───────▼──────────┐  ┌────▼─────────────┐
 │   CHANNELS    │   │    AGENT CORE    │  │   TASK SYSTEM    │
 └───────────────┘   └──────────────────┘  └─────────────────┘
         │                   │                   │
 ┌───────▼───────┐   ┌───────▼──────────┐  ┌────▼─────────────┐
 │   TELEGRAM    │   │   LLM ENGINE     │  │    WORKER POOL   │
 │   (input)     │   │   (provider)     │  │   (async tasks)  │
 └───────────────┘   └──────────────────┘  └─────────────────┘
         │                   │                   │
         └───────────────────┴───────────────────┘
                             │
             ┌───────────────┼───────────────┐
             │               │               │
     ┌───────▼───────┐ ┌────▼──────┐ ┌──────▼──────┐
     │   SKILLS      │ │   TOOLS   │ │  WORKSPACE  │
     │   SYSTEM      │ │  SYSTEM   │ │  (context)  │
     └───────────────┘ └───────────┘ └─────────────┘
             │               │               │
     ┌───────▼───────────────▼───────────────▼───────┐
     │            AGENT CONTEXT (IDENTITY, etc.)      │
     └────────────────────────────────────────────────┘
```

## Основные компоненты

### Message Bus

Message bus — основа архитектуры Nexbot, позволяющая декомпозированное общение между компонентами.

**Компоненты:**
- **Inbound Queue**: Хранит входящие сообщения (Telegram, запланированные задачи)
- **Outbound Queue**: Хранит исходящие сообщения (ответы, уведомления)
- **Task Queue**: Хранит фоновые задачи (worker pool, cron задания)

**Поток данных:**
```
Telegram → Inbound Queue → Agent → Outbound Queue → Telegram
                                    │
                              Task Queue
                                    │
                              Worker Pool / Subagents
```

**Реализация:** Использует Go каналы с буферизированными очередями для высокой пропускной способности.

### Agent Core

Agent loop — основной блок обработки, который координирует обработку сообщений, взаимодействие с LLM и tool calling.

**Процесс:**
1. Получить сообщение из inbound queue
2. Загрузить контекст из workspace (IDENTITY, AGENTS, SOUL, USER)
3. Отправить сообщение LLM провайдеру
4. Парсить ответ LLM
5. Выполнить tool calls, если есть
6. Обработать spawning subagent, если есть
7. Отправить результат в outbound queue
8. Повторить

**Ключевые возможности:**
- Context builder с упорядоченным приоритетом (IDENTITY → AGENTS → SOUL → USER → TOOLS → MEMORY)
- Tool calling с максимумом итераций (по умолчанию 20)
- Координация subagents
- Обработка timeout (по умолчанию 30 секунд)

### Channels

Channels — входные/выходные коннекторы, которые получают сообщения и отправляют ответы.

**Текущие каналы:**
- **Telegram Channel**: Подключается к Telegram ботам через библиотеку telego

**Расширяемая архитектура:**
Новые каналы можно добавить, реализовав интерфейс `Channel`:
- `Connect() error` - Установить соединение
- `HandleMessage(msg) error` - Обработать входящее сообщение
- `SendMessage(msg) error` - Отправить ответ

### LLM Engine

Управляет коммуникацией с разными LLM провайдерами.

**Поддерживаемые провайдеры:**
- **Z.ai**: GLM-4.7 Flash (по умолчанию)
- **OpenAI**: Модели GPT

**Возможности:**
- Абстракционный слой провайдера
- Обработка ошибок и повторы
- Подсчёт токенов
- Управление timeout

### Tools System

Встроенные инструменты, расширяющие возможности агента.

**Встроенные инструменты:**
- `read_file` - Прочитать содержимое файла
- `write_file` - Записать содержимое файла
- `list_dir` - Список содержимого директории
- `shell_exec` - Выполнить shell команды
- `spawn` - Создать subagents (v0.2)

**Интерфейс Tool:**
```go
type Tool struct {
    Name        string
    Description string
    Execute     func(ctx context.Context, args map[string]interface{}) (interface{}, error)
    Schema      llm.ToolDefinition
}
```

### Skills System

Skills — markdown файлы, которые обучают агента использовать инструменты или выполнять задачи.

**Структура:**
```
skills/
├── weather/
│   └── SKILL.md
├── github/
│   └── SKILL.md
└── custom/
    └── SKILL.md
```

**Формат файла Skill:**
```markdown
---
name: weather
description: Provides weather information
tools: [read_file, shell_exec]
---
```

### Workspace

Директория workspace (`~/.nexbot/`) хранит контекст агента и данные.

**Bootstrap файлы:**
1. **IDENTITY.md** - Основная идентичность бота
2. **AGENTS.md** - Инструкции агента и поведение
3. **SOUL.md** - Личность и тон бота
4. **USER.md** - Профиль пользователя и предпочтения
5. **TOOLS.md** - Справка по инструментам
6. **MEMORY.md** - Долгосрочная память

**Порядок сборки контекста:**
```
IDENTITY → AGENTS → SOUL → USER → TOOLS → MEMORY
```

## Новые компоненты v0.2

### Cron Scheduler

Фоновый планировщик для выполнения задач в определённое время с помощью cron выражений.

**Компоненты:**
- **Cron Engine**: Основан на библиотеке robfig/cron/v3
- **Job Store**: JSON файл для определений задач
- **Поддержка Timezone**: Настраиваемый timezone для каждой задачи
- **Logging**: Логи выполнения в nexbot.log

**Архитектура:**
```
Cron Engine
    │
    ├─ Парсинг cron выражений
    ├─ Отслеживание запланированного времени
    ├─ Триггер выполнения задачи
    └─ Логирование результатов выполнения
```

**Формат хранения задач:**
```json
{
  "jobs": [
    {
      "name": "job-name",
      "cron": "0 3 * * *",
      "description": "Task description",
      "enabled": true
    }
  ]
}
```

**Формат cron выражений:**
```
* * * * *
│ │ │ │ │
│ │ │ │ └─── День недели (0-7, 0 и 7 — воскресенье)
│ │ │ └───── Месяц (1-12)
│ │ └─────── День месяца (1-31)
│ └───────── Час (0-23)
└─────────── Минута (0-59)
```

**Ключевые возможности:**
- Стандартный синтаксис cron совместимый с [robfig/cron](https://pkg.go.dev/github.com/robfig/cron/v3)
- Timezone-aware планирование
- JSON хранение задач
- Логирование выполнения
- Обработка ошибок и повторы

### Subagent Manager

Управляет созданием и выполнением независимых процессов агента.

**Компоненты:**
- **Subagent Manager**: Создаёт и координирует subagents
- **Управление сессиями**: Уникальные session ID для каждого subagent
- **Изоляция контекста**: Отдельный контекст для каждого subagent
- **Маршрутизация сообщений**: Результаты возвращаются главному агенту

**Архитектура:**
```
Main Agent
    │
    ├─ Триггер spawn tool
    │
    └─ Subagent Manager
            │
            ├─ Создать session ID
            ├─ Клонировать контекст (base)
            ├─ Spawn процесса агента
            ├─ Запустить agent loop
            ├─ Захватить вывод
            └─ Вернуться к главному агенту
```

**Конфигурация:**
```toml
[subagent]
enabled = true
max_concurrent = 10
timeout_seconds = 300
session_prefix = "subagent-"
```

**Ключевые возможности:**
- Поддержка одновременных subagents (настраиваемый лимит)
- Изолированный контекст выполнения
- Управление timeout
- Очистка ресурсов
- Логирование активности всех subagents

### Worker Pool

Управляет async выполнением задач для параллельной обработки.

**Компоненты:**
- **Worker Pool**: Пул goroutines фиксированного размера
- **Task Queue**: Буферизированный канал для ожидающих задач
- **Task Execution**: Выполнение задач асинхронно
- **Result Collection**: Возврат результатов вызывающему

**Архитектура:**
```
Main Agent
    │
    ├─ Отправить задачу в очередь
    │
    └─ Worker Pool
            │
            ├─ Worker 1
            ├─ Worker 2
            ├─ Worker 3
            ├─ Worker 4
            └─ Worker 5
            │
            └─ Вернуть результаты
```

**Конфигурация:**
```toml
[workers]
pool_size = 5
queue_size = 100
```

**Ключевые возможности:**
- Фиксированный размер пула для предсказуемого использования ресурсов
- Буферизированная очередь для обработки пиков
- Асинхронное выполнение без блокировки главного агента
- Сбор результатов
- Пропагация ошибок

### HEARTBEAT System

Задачи health check с настраиваемыми интервалами.

**Компоненты:**
- **Heartbeat Engine**: Запускает проверочные задачи по расписанию
- **Task Scheduler**: Интеграция с cron системой
- **Task Definition**: Файлы HEARTBEAT.md в workspace
- **Result Logging**: Результаты health check

**Архитектура:**
```
HEARTBEAT.md files
    │
    ├─ interval: 300 (seconds)
    ├─ description: System health check
    └─ tasks:
        ├─ Check service status
        ├─ Verify disk space
        ├─ Review error logs
        └─ Generate health report
```

**Ключевые возможности:**
- Настраиваемые интервалы
- Гибкие определения задач
- Структурированный вывод
- Интеграция с cron задачами
- Отслеживание истории выполнения

## Поток данных

### Основной поток сообщений

```
1. Telegram Message
   ↓
2. Telegram Channel получает сообщение
   ↓
3. Сообщение добавлено в Inbound Queue
   ↓
4. Agent Loop извлекает сообщение из очереди
   ↓
5. Загрузка контекста из файлов workspace
   ↓
6. Отправка LLM провайдеру (Z.ai)
   ↓
7. Парсинг ответа LLM
   ↓
8. Выполнение tool calls (если есть)
   ↓
9. Spawn subagents (если запрошено)
   ↓
10. Отправка ответа в Outbound Queue
    ↓
11. Telegram Channel отправляет ответ
```

### Поток Cron задач

```
1. Cron Engine запускается по расписанию
   ↓
2. Поиск соответствующей cron задачи
   ↓
3. Триггер выполнения задачи
   ↓
4. Создание задачи в Task Queue
   ↓
5. Worker Pool забирает задачу
   ↓
6. Выполнение логики задачи
   ↓
7. Логирование результатов выполнения
   ↓
8. Сохранение результатов в логах
```

### Поток Subagent

```
1. Главный агент вызывает spawn tool
   ↓
2. Subagent Manager получает запрос
   ↓
3. Генерация уникального session ID
   ↓
4. Клонирование контекста главного агента
   ↓
5. Создание экземпляра subagent
   ↓
6. Запуск subagent loop
   ↓
7. Обработка сообщений/инструментов независимо
   ↓
8. Возврат результатов главному агенту
   ↓
9. Очистка ресурсов subagent
```

### Поток Worker Pool

```
1. Задача отправлена в очередь
   ↓
2. Задача добавлена в буферизированный канал
   ↓
3. Worker доступен? Да → Обработка
   ↓
4. Worker выполняет задачу
   ↓
5. Результат собран
   ↓
6. Worker возвращается в пул
   ↓
7. Задача отмечена как завершённая
```

## Архитектура конфигурации

### Структура файла конфигурации

```
config.toml
├── [workspace] - Настройки workspace
├── [agent] - Поведение агента
├── [llm] - Настройки LLM провайдера
├── [llm.zai] - Специфичные настройки Z.ai
├── [llm.openai] - Специфичные настройки OpenAI
├── [logging] - Конфигурация логирования
├── [channels] - Коннекторы каналов
│   ├── [channels.telegram] - Конфигурация Telegram
│   └── [channels.discord] - Конфигурация Discord
├── [tools] - Конфигурация инструментов
│   ├── [tools.file] - File инструменты
│   └── [tools.shell] - Shell инструменты
├── [cron] - Cron планировщик (v0.2)
├── [workers] - Worker pool (v0.2)
├── [subagent] - Subagent manager (v0.2)
└── [message_bus] - Настройки message bus
```

### Иерархия конфигурации

```
Command Line Flag (наивысший приоритет)
    ↓
config.toml в текущей директории
    ↓
~/.nexbot/config.toml (по умолчанию)
    ↓
Переменные окружения (используются для секретов)
```

## Производительность

### Управление ресурсами

- **Message Bus**: Использует буферизированные каналы с настраиваемой ёмкостью
- **Worker Pool**: Фиксированный размер для предсказуемого использования памяти
- **Subagent Manager**: Лимит одновременных процессов предотвращает истощение ресурсов
- **Cron Engine**: Минимальные накладные расходы, эффективное отслеживание времени

### Конкурентность

- **Goroutines**: Эффективны для I/O-bound операций
- **Channels**: Low-latency передача сообщений
- **Mutex/Channel**: Безопасные паттерны конкурентного доступа
- **Context**: Правильная отмена долгих задач

### Масштабируемость

- **Горизонтально**: Можно масштабировать добавляя больше worker процессов
- **Вертикально**: Можно масштабировать увеличивая размер пула/ёмкость очереди
- **Декомпозировано**: Каждый компонент можно оптимизировать независимо

## Архитектура безопасности

### Валидация ввода

- **Конфигурация**: Schema валидация при запуске
- **Аргументы инструментов**: Whitelist паттерны
- **Path Traversal**: Всегда блокируется (функция безопасности)
- **Переменные окружения**: Только валидация ссылок

### Контроль доступа

- **Telegram**: User/Chat whitelisting
- **Операции с файлами**: Whitelist директорий
- **Shell команды**: Whitelist команд
- **Subagents**: Лимиты конкурентности

### Управление секретами

- **Переменные окружения**: Рекомендуется для API ключей
- **Права на файлы**: Файлы конфигурации должны быть доступны только пользователю
- **No Hardcoding**: Никогда не коммитить API ключи в репозиторий

## Стратегия тестирования

### Unit тесты

- Каждый компонент тестируется изолированно
- Mock интерфейсы для внешних зависимостей
- Тесты валидации конфигурации

### Интеграционные тесты

- Поток message bus
- Выполнение инструментов
- Создание subagent
- Выполнение cron задач

### End-to-End тесты

- Полный workflow агента
- Несколько инструментов вместе
- Взаимодействие subagent + главный агент

## Будущая архитектура

### Планируемые улучшения

1. **Слой базы данных** (v0.5)
   - SQLite хранилище для персистентности
   - История сессий
   - Функциональность backup/restore

2. **Поддержка MCP** (v1.1)
   - MCP клиент для внешних инструментов
   - Управление MCP серверами
   - Обёртывание MCP инструментов

3. **Web UI** (v0.4)
   - REST API для внешнего доступа
   - Dashboard для мониторинга
   - Конфигурационный UI

4. **Больше каналов** (v0.4)
   - Discord коннектор
   - Slack коннектор
   - Email уведомления

## Ссылки

- [Message Bus Design](https://martinfowler.com/articles/patterns-of-distributed-systems/MessageBus.html)
- [Go Concurrency](https://go.dev/doc/effective_go#concurrency)
- [robfig/cron](https://pkg.go.dev/github.com/robfig/cron/v3)
- [Context Package](https://pkg.go.dev/context)

---

**Последнее обновление:** v0.2.0 Архитектура
